[Lab instructions](https://pdos.csail.mit.edu/6.824/labs/lab-kvsrv.html)

## Some notes

- Although this lab is marked as easy, I was still stuck for quite a while to pass all tests. The reason in the end was I did not read the [lecture notes](https://pdos.csail.mit.edu/6.824/notes/l-linearizability.txt) and the lab instructions carefully. The mistakes I made include:
  - I forgot the `Get` request can always either read old or new values even if the request is retransmitted.
  - I didn't realize that the server does not need to reply the `Put` request.
- Due to these mistakes, I couldn't pass most memory tests and spent long time optimizing the wrong direction.

## Implementation

### RPC
- A client can send three types of requests to the server: `Get`, `Put`, `Append`.
  - `Get`: there is only the `Key` argument in the `Get` request. The server then replies the latest `Value` stored in the `Key`.
  - `Put` or `Append`: there are 4 arguments in either request:
    - `Key`: the requested key
    - `Value`: the value to either put or append to the key
    - `Cid`: a big random number as the identifer of each client, this is generated by `nrand()` in `client.go` provided in the lab skeleton. 
    - `Seq`: a request sequence number maintained by each client, incremented by one for each `Put` or `Append` request.
- The server does not reply to the `Put` request. For the `Append` request, the server replies the old value before the appending.

### Client
- Each client is initialized with its `ck.cid := nrand()` and a `ck.seq := 0`.
- To send a `Get` request, a client puts the `Key` argument in the request, and keeps sending the same request until it gets the reply.
- To send a `Put` or `Append` request, a client first increments the `ck.seq := ck.seq + 1`, then sends them in the request along with the `Key` and `Value`.

### Server
- The server maintains the following objects:
  - `mu`: a lock to guard the atomic access of other objects.
  - `kvs`: the key-value map that always stores the latest values for each key
  - `acks`: a map from a `cid` to `Ack`, which stores the last `Seq` and `Value` (only for `Append` requests) the server has replied to it.
- When the server receives a `Get` request, it always replies the latest value `kvs[args.Key]` without updating `acks`. 
  - This is linearizable as the `Get` is a read-only request (see example 7 in the lecture notes for details).
- When the server receives a `Put` request from a client `cid`, it first checks whether it has seen the request before. If `acks[cid].Seq == args.Seq`, then the server does nothing, otherwise it updates `kvs[args.Key]` and stores `args.Seq` in `acks[cid]`.
  - If the server re-executes the same `Put` requests twice, it breaks the linearizability, see example 6 in the lecture notes for details.
- When the server receives a `Append` request, it firsts checks whether the request is a retransmission as in checking a `Put` request:
  - If `args.Seq > acks[cid].Seq`, the server replies `kvs[args.Key]` first, then append `args.Value` to the key, and lastly store `args.Seq` and `reply.Value` in `acks[cid]`. 
  - If `args.Seq == acks[cid].Seq`, then the server replies `acks[cid].Value` only.


## Clarafications

- In theory, two clients could generate the same `Cid`, but this is not considered in the current implementation.
- Different goroutines spawned by the `Clerk` share the same process id, hence `Cid` cannot be replaced by `os.getPid()`.
- The mechanism to identify duplicate request is inspired by the tcp protocol.

    
